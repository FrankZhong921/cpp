



# 数据结构

## 优先队列 priority_queue

#### LC239.  滑动窗口最大值

给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。

返回滑动窗口中的最大值。

<img src="C:\Users\921-\AppData\Roaming\Typora\typora-user-images\image-20210511201830747.png" alt="image-20210511201830747" style="zoom: 67%;" />

解题思路：

- 暴力方法：以使用 *O(k)* 的时间遍历其中的每一个元素，找出其中的最大值。对于长度为 *n* 的数组 nums 而言，窗口的数量为 *n-k+1*，因此该算法的时间复杂度为 *O((n−k+1)k)=O(nk)*，会超出时间限制

- 优先队列：可以想到，对于两个相邻（只差了一个位置）的滑动窗口，它们共用着 *k*−1 个元素，而只有 1个元素是变化的。

  对于「最大值」，我们可以想到一种非常合适的数据结构，那就是优先队列（堆），其中的大根堆可以帮助我们实时维护一系列元素中的最大值。

  初始时，我们将数组 *nums* 的前 k 个元素放入优先队列中。每当我们向右移动窗口时，我们就可以把一个新的元素放入优先队列中，此时堆顶的元素就是堆中所有元素的最大值。然而这个最大值可能并不在滑动窗口中，在这种情况下，这个值在数组 *nums* 中的位置出现在滑动窗口左边界的左侧。因此，当我们后续继续向右移动窗口时，这个值就永远不可能出现在滑动窗口中了，我们可以将其永久地从优先队列中移除。
  我们不断地移除堆顶的元素，直到其确实出现在滑动窗口中。此时，堆顶元素就是滑动窗口中的最大值。为了方便判断堆顶元素与滑动窗口的位置关系，我们可以在优先队列中存储二元组*(num,index)*，表示元素 *num* 在数组中的下标为 *index*。

  ```c++
  vector<int> maxSlidingWindow(vector<int>& nums, int k) {
          priority_queue<pair<int,int >> pdeque;
          //将前k个数构成最大堆，此时为初始窗口
          for(int i=0; i< k; i++){	
              pdeque.push({nums[i],i});
          }
          //将初始窗口的最大值存入结果
          vector<int> res({pdeque.top().first});
          //窗口逐元素右移
          for(int i = k; i<nums.size(); i++){
          	//将新进入窗口的元素加入堆中
              pdeque.push({nums[i],i});
              //在拿出最大元素之前，判断堆顶的元素是否在窗口中
              while(pdeque.top().second <= i-k){
                  pdeque.pop();
              }
              //将堆顶最大元素加入结果
              res.push_back(pdeque.top().first);
             
          }
          return res;
      }
  ```

  **时间复杂度 O(nlogn)** :主要是插入元素维护最大堆所需要的时间.其中 n 是数组 nums 的长度。在最坏情况下，数组 nums 中的元素单调递增，那么最终优先队列中包含了所有元素，没有元素被移除。由于将一个元素放入优先队列的时间复杂度为 O(logn)，因此总时间复杂度为O(nlogn)。

  **空间复杂度 O(n)** : 优先队列大小

  - 单调队列：顺着优先队列的方法进行优化

  

  

  

  

  

  

  

# 算法

# 查找

### 二分查找

```c++
void BinarySearch(vector<int> arr,int target){
	int lo = 0;
    int hi = arr.size();
    //遵循c++使用的左闭右开原则,也可用　lo <= hi,但对应边界也需要修改
    while(lo < hi){
        int mid = lo + (hi -lo)/2;
        if( target < arr[mid]) hi = mid;
        else if( target > arr[mid]) lo = mid + 1;
        else{
			return mid;
        }
    }
    return -1;
}
```

#### c++通用算法：

```C++
//binary_search()函数定义在<algorithm>头文件中，用于查找指定区域内是否包含某个目标元素．
//查找[first,last]区域内是否包含val
bool binary_search(ForwardIterator first,ForwardIterator last,const T& val);
//根据 comp　指定的比较规则进行查找
bool binary_search(ForwardIterator first, ForwardIterator last, const T& val , Compare comp);

//第二种语法格式的底层实现
template<class ForwardIterator, class T, class Compare>
bool binary_search(ForwardIterator first, ForwardIterat last, const T& val, Compare comp)
{
    first = std::lower_bound(first, last, val, comp);
    return (!(first == last) && !(comp(val, *first)));
}
```



#### 应用：

​	可在**已排序**的，且其元素可比较的序列中寻找某个值．常见的比如白名单，黑名单匹配．

## 排序

###  O(n^2)级排序算法

#### 冒泡排序

##### 剑指offer45

##### LC 283



#### 选择排序

##### LC 215

##### LC 912

#### 插入排序

##### LC 912

##### LC 147

### O(nlogn)级排序算法

#### 希尔排序

​	插入排序突破O( n ^ 2 )的本质可通过**逆序对**来解释

- 将数组按从小到大进行排序，若一个元素值比它后面的元素大，那么这两个元素组成一个逆序对

**而希尔排序就是通过交换间隔较远的元素，使得一次交换可以消除一个以上的逆序对．**

希尔排序算法就是通过这种方式，打破了在空间复杂度为 O(1) 的情况下，时间复杂度为O(n^2)的魔咒，此后的快排、堆排等等算法也都是基于这样的思路实现的。



**LC 912**

##### LC 506　相对名次

因为计算名次必须先经过排序得到名次数组*sorted*，排序完原数组*arr*顺序打乱，

- 有序数组的元素索引为名次，元素为分数;

- 原数组元素索引标识运动员，元素为分数

  因此需要建立　原数组元素索引－> （原数组元素值－> 有序数组元素值）　－>　有序数组元素索引即名次　的映射关系．

  1. 记录下名次，即有序数组*sorted*索引*i*
  2. 在原数组中*arr*中查找*sorted[i]*，即分数值，对应在*arr*中的索引为*j*
  3. *arr[j] = i*

  根据２中的查找，有两种思路：

  1. 使用查找算法，找到*j*;
  2. 建立映射，使用map





#### 堆排序

- 堆：符合一下两个条件的完全二叉树

  1. 根节点的值 ≥ 子节点的值，这样的堆被称之为最大堆，或大顶堆；
  2. 根节点的值 ≤ 子节点的值，这样的堆被称之为最小堆，或小顶堆。

- 堆排序需要解决的两个问题

  1. 如何用数列构建出一个堆
     - **完全二叉树的性质**：
       1. 对于完全二叉树中的第 `i` 个数，它的左子节点下标：`left = 2i + 1`
       2. 对于完全二叉树中的第 `i` 个数，它的右子节点下标：`right = left + 1`
       3. 对于有 `n` 个元素的完全二叉树(n≥2)，它的最后一个非叶子结点的下标：`n/2 - 1`
     - 将整个待排序的数列视为一棵完全二叉树，自底向上调整成堆．
  2. 取出堆顶数字后，如何将剩余的数字调整为堆

  

##### LC 215

##### 剑指offer 40

#### 快速排序

##### LC 912

##### LC 169

#### 归并排序

##### 面试题 10.01 合并排序数组

##### 剑指offer 51 数组中的逆序对

### O(n)级排序算法

#### 计数排序

##### LC 912

##### LC 1122 

#### 基数排序

##### LC 164

##### LC 561

### 其它的排序

#### 猴子排序

无限猴子定理：让一只猴子在打字机上随机地按键，当按键时间达到无穷时，几乎必然能够打出任何给定的文字，比如莎士比亚的全套著作。

根据全排列计算公式，一个数组可能组成的所有排列的总数量为 n!，所以猴子排序的时间复杂度 O*(*n!)，空间复杂度 O(1)。

#### 奇迹排序

今天，业务部门让我给数组排序，我拿到数据后，马上检查了一下他们给我的数组是否有序。
噢！糟糕，它是无序的！
然后我静静等待了了两秒钟，又检查了一遍。
噢！为什么？它还是无序的！
那我待会再来检查看看，一定会有神迹发生。

时间复杂度 O(∞)，空间复杂度 O(1)。

#### 睡眠排序

每个数字输入时，开启一个线程，让其睡眠，睡眠时长等于这个数字的大小，睡眠结束后，输出此数字。
每个数字的大小不同，输出的顺序也不同，所有数字都输出后，排序完成！

类似于计数排序的思想，利用数字本身的属性完成排序。时间复杂度 O(n+k)（`k` 表示数据范围），空间复杂度 O(1) 。

#### 意大利面排序

将数字反映为意大利面条的长短，将其排列到桌子上，用右手👋从底部往上缓缓移动，触碰到某一根面条🍜时，将其记录下来。直到完成整个排序。

类似于计数排序的思想。时间复杂度 O(n+k)（`k` 表示数据范围），空间复杂度 O(1)*O*(1)。

# 字符串

#### 剑指Offer 58-ll 左旋字符串

​	**字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。**请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串"abcdefg"和数字2，该函数将返回左旋转两位得到的结果"cdefgab"。

解法：

1. 切片

   ```c++
   string reverseLeftWords(string s, int n) {
           return string(begin(s)+n,end(s)) + string(begin(s),begin(s)+n);
       }
   
   //空间复杂度O(N)：两个字符串   时间复杂度O(N)：字符串切片函数为线性时间复杂度
   ```

2. 遍历字符串拼接：一个一个字符遍历，得到要旋转的左字串

3. 三次旋转：

   c++中string类型是可变的，因此可在原字符串上直接操作实现字符串旋转，实现*O(1)* 的空间复杂度。

   ```c++
   string reverseLeftWords(string s, int n) {
           reverseString(s, 0, n-1);//对于字符串左右对称操作，使用左右闭区间[0]更加简洁
           reverseString(s, n, s.size()-1);
           reverseString(s, 0, s.size()-1);
           return s;
       }
   void reverseString(string& s, int i, int j) {
           while(i < j) swap(s[i++], s[j--]);
       }
   ```

   

# 算术题

### 不用+-*/做加法

剑指offer 65

```CPP
class Solution {
public:
    int add(int a, int b) {
        while( b != 0){
            int c = (unsigned int)(a & b )<< 1; //进位.c++不支持负数的移位操作，需转为无符号数
            a ^= b; //无进位和    
            b = c;
        }
        //while下一次循环与 进位b　再进行无进位加法
        return a;
    }
};
```

