# 第一章 基础

1. 使用管道与重定向读入与写出数据、

   ```java
   //使用>将输出重定向到data.txt，而不是直接打印到终端
   % java RandomSeq 1000 100.0 200.0 > data.txt、
   //使用<将文件输入
   % java Average < data.txt
   //使用 | 将Random的标准输出和Average的标准输入指定为同一个流
   % java RandomSeq 1000 100.0 200.0 | java Average
   ```

## 背包

- 一种**不支持从中删除元素**的集合数据类型，它的目的就是帮助用例收集元素并迭代遍历所有收集到的元素。*使用bag可以说明元素的处理顺序不重要。*

## 先进先出队列

- 应用：
  1. 排队问题：优先为等待最久的人或者说最先到达的人服务
  2. 文件读取：无需知道文件的大小，即可将文件的所有数据读入到一个数组中。首先将所有的数据的读入队列中，然后使用队列的size()成员得到数组的大小，从而创建数组并将队列中的所有整数移动到数组中。（由于队列能够按照数据在文件中的顺序放入数组中）

## 下压栈

- 如果栈大小是动态分配的，则*push()*前判断元素大小是不是等于capcity，*pop()* 时判断元素是不是小于1/4，这样大小减半时元素约为半满．

- 应用：

  1. 网页访问：点击一个超链接时，浏览器会显示新的页面，同时将旧页面压入栈中，这样我们可以不断的点击超链接访问新的页面，也可以通过回退按钮重新访问以前的页面。

  2. 在用保存元素的同时颠倒它们的相对顺序

  3. 算数表达式求值

     - Dijkstra：用两个栈（一个保存运算符，一个保存操作数）

       1. 将操作数压入操作数栈
       2. 将运算符压入运算符栈
       3. 忽略左括号
       4. 在遇到右括号时弹出一个运算符，弹出其所需数量的操作数，并将运算结果压入操作数栈

       在处理完表达式后，操作数栈中只会有一个值，即为表达式的处理结果

## 链表

### 基于链表的栈实现

将栈保存为一条链表，**栈顶即为表头**，使用一个指向链头的指针即可

```c++
//position: /usr/include/c++/10/bits/stl_stack.h
/**
   *  @brief  A standard container giving FILO behavior.
   *  @ingroup sequences
   *  @tparam _Tp  Type of element.
   *  @tparam _Sequence  Type of underlying sequence, defaults to deque<_Tp>.
   *  Meets many of the requirements of a
   *  <a href="tables.html#65">container</a>,
   *  but does not define anything to do with iterators.  Very few of the
   *  other standard container interfaces are defined.
   *  This is not a true container, but an @e adaptor.  It holds
   *  another container, and provides a wrapper interface to that
   *  container.  The wrapper is what enforces strict
   *  first-in-last-out %stack behavior.
   *
   *  The second template parameter defines the type of the underlying
   *  sequence/container.  It defaults to std::deque, but it can be
   *  any type that supports @c back, @c push_back, and @c pop_back,
   *  such as std::list, std::vector, or an appropriate user-defined
   *  type.
   *
   *  Members not found in @a normal containers are @c container_type,
   *  which is a typedef for the second Sequence parameter, and @c
   *  push, @c pop, and @c top, which are standard %stack/FILO
   *  operations.
  */
 template<typename _Tp, typename _Sequence = deque<_Tp> >
 class stack{
     typedef typename _Sequence::value_type _Sequence_value_type;
     public:
      typedef typename _Sequence::value_type		value_type;
      typedef typename _Sequence::reference			reference;
      typedef typename _Sequence::const_reference	const_reference;
      typedef typename _Sequence::size_type		    size_type;
      typedef	       _Sequence					container_type;
	 protected:
      _Sequence c;
     template<typename _Seq = _Sequence, typename _Requires = typename
	       enable_if<is_default_constructible<_Seq>::value>::type>
	 stack(): c() { }
     explicit stack(const _Sequence& __c): c(__c) { }
     explicit stack(_Sequence&& __c): c(std::move(__c)) { }
     
	 template<typename _Alloc, typename _Requires = _Uses<_Alloc>>
	 explicit stack(const _Alloc& __a): c(__a) { }

     template<typename _Alloc, typename _Requires = _Uses<_Alloc>>
	 stack(const _Sequence& __c, const _Alloc& __a): c(__c, __a) { }

     template<typename _Alloc, typename _Requires = _Uses<_Alloc>>
	 stack(_Sequence&& __c, const _Alloc& __a): c(std::move(__c), __a) { }

     template<typename _Alloc, typename _Requires = _Uses<_Alloc>>
	 stack(const stack& __q, const _Alloc& __a): c(__q.c, __a) { }

     template<typename _Alloc, typename _Requires = _Uses<_Alloc>>
	 stack(stack&& __q, const _Alloc& __a): c(std::move(__q.c), __a) { }
     
     bool empty() const { return c.empty(); }
     size_type size() const { return c.size(); }
     reference top(){
		__glibcxx_requires_nonempty();
		return c.back();
     }
     void pop(){
		__glibcxx_requires_nonempty();
		c.pop_back();
     }

     void push(const value_type& __x){ c.push_back(__x); }
     void push(value_type&& __x) { c.push_back(std::move(__x)); }
     #if __cplusplus > 201402L
     template<typename... _Args>
	 decltype(auto) emplace(_Args&&... __args){ return c.emplace_back(std::forward<_Args>(__args)...); }
	 #else
     template<typename... _Args>
	 void emplace(_Args&&... __args) { c.emplace_back(std::forward<_Args>(__args)...); }
     
     template<typename _Tp, typename _Seq>
     inline bool operator==(const stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y){ 
         return __x.c == __y.c; }
     
     template<typename _Tp, typename _Seq>
     inline bool operator!=(const stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y){ 
         return !(__x == __y); }
```

### 基于链表的队列实现

```c++
//position: /usr/include/c++/10/bits/stl_queue.h
//大部分操作与stack适配器相同
template<typename _Tp, typename _Sequence = deque<_Tp> >
class queue{
	...
	reference front(){
		__glibcxx_requires_nonempty();
		return c.front();
    }
    reference back(){
		__glibcxx_requires_nonempty();
		return c.back();
    }
    void
    push(const value_type& __x){	c.push_back(__x); }

    /**
       *  @brief  Removes first element.
       *
       *  This is a typical %queue operation.  It shrinks the %queue by one.
       *  The time complexity of the operation depends on the underlying
       *  sequence.
       *
       *  Note that no data is returned, and if the first element's
       *  data is needed, it should be retrieved before pop() is
       *  called.
       *　pop的时间复杂度取决于底层数据结构，返回值为空
       */
    void pop(){
		__glibcxx_requires_nonempty();
		c.pop_front();
     }
    ...
}
```

## 二叉树

### 相关定义

- **树的递归定义**
  1. 空结构是一颗空树
  2. 如果t1,...tk是不相交的树，那么，以t1,..,tk的根作为子节点的数据结构也是一棵树
  3. 只有通过第１步和第２步产生的数据结构才是树
- 根节点到任意节点经过的唯一路径称为路径
- 路径中弧的长度称为**路径的长度**．
- 节点的**层次**是路径+１，也即该路径上节点的数量
- 非空树的**高度**是树中节点的最大层次
- **完全二叉树**：**除最后一个层次**，对于每一层的所有节点都有两个子节点，即第 i 层有 2^(i-1) 个节点的二叉树
  - 对于非空二叉树来说，若所有非叶子节点都有两个非空子节点（即不存在链表状，只有单个子节点的非叶子节点）叶子节点的数目 m 大于所有非叶子节点，且m = k +1;
  - 综上，i 层完全决策树（不存在单子节点的完全二叉树）具有2^i - 1个节点
- **二叉查找树**：对于每个节点，其左子树中的值小于该节点，其右子树中的值大于该节点

### 广度优先遍历(breadthFirst)

- 迭代+队列

### 深度优先遍历

- **递归实现**
- **迭代+栈**
  1. 前序
  2. 中序
  3. 后序
- **空间O(1)迭代**
  1. 线索树
  2. Morris遍历

## union-find算法

- 联通性问题：我们的程序能够判别给定的整数对p q是否相连

  应用：

- 在设计算法时面对的第一个问题就是精确的定义问题．

- 所需基本操作

  -  void union(int p , int q)  在p和q之间添加一条连接，负责分量归并
  - int find (int p) p所在的分量的标识符（0 到 N-1）
  - bool connected(int p, int q)   p和q是否相连，是否是同一个连通分量
  - int count()  连通分量的数目

  1. 使用一个 *int[]* 来表示所有的分量，初始化 *id[i] = i ;*
  2.  对于每个触点i，使用find()方法来判定它所在的分量所需的信息保存在 *id[i]*;
  3. *connected()* 方法只用　*find(p) == find(q);*
  4. 每*union()*　一次，*count* 的数目减１

### 实现

- **quick find算法**：保证当且仅当id[p] == id[q]　时，p和q才是连通的．即，同一个连通分量的所有触点在id[]中的值必须全部相同．也意味着connected(p,q) 仅需判断 id[p] == id[q]．

  在使用union 之前判断两者是不是同一个连通分量，如果是，我们可以忽略，否则两者不是同一个连通分量，那其中一个连通分量的所有id[i]都需要修改，使得两个联通分量合二为一

  ```cpp
  void union(int p,int q){
  	int pID = find(p);
  	int qID = find(q);
  	if(pID == qID) return;
  	for(int i=0; i< id.size();i++){
  		if(pID == id[i]){
  			id[i] = qID;
  		}
  	}
  	count--;
  }
  ```

- **算法分析**

  对于每一个触点，如果不在同一个连通分量，都需要遍历一遍数组．每次调用find() 直接访问数组一次，

  而union() 遇到在同一个连通分量时需要访问数组２次，

  不在同一个连通分量中，最少情况下只有两个连通分量，要并的分量只有一个触点，那么将find 2次，for循环内if判断Ｎ次，赋值１次，共**Ｎ+３**次；　		最多情况下只有两个联通分量，要并的分量有Ｎ－１个触点，那么将find 2次，for循环内if判断Ｎ次，赋值Ｎ－１次，共**２Ｎ+１**次

  如果最终得到一个连通分量，那需要Ｎ－１次union，至少需要(N-1)(N+3)~N^2 次数组访问，该算法为平方级别．

  

- **quick union 算法**

  和**quick find**互补．同样使用 *id[]* 来记录，不过 *id[i]* 指向同一个连通分量的另外一个触点．

  在实现 *find()* 时，从给定触点开始，由它的 *id[i]* 找到另外一个触点，再由这个触点找到第三个触电...　直到一个根触点．当且仅当分别由两个触点开始这个寻找过程最终到达同一个根触点时，两个触点同属于一个连通分量．

  实现 *union()* 时，由 *find* 找到p和q的根触点，若两者不相同，仅需将其中一个根触点链接到另外一个根触点即可

  ```cpp
  int find(int p){
  	while(p != id[p]) p = id[p]; //根触点i的id[i]为i
  	return p;
  }
  void union(int p,int q){
  	int pID = find(p);
  	int qID = find(q);
  	if(pID == qID) return;
  	id[qID] = pID;
  	count--;
  }
  ```

- **算法分析：**

  *find()* 最好的情况下一次就能找到根触点，此时 *union* 需要 2次find访问数组，１次赋值，共３次

  最坏的情况下Ｎ－１次才能找到根触点，此时 *union* 需要两次find，每次需要Ｎ－１次访问，最后一次赋值，共２Ｎ－１次

  因此每次find都能在最好的情况下，则需要线性时间复杂度，如果在最坏的情况下则需要平方时间复杂度



- **加权quick union算法**

  只需简单修改一下**quick union算法**就能保证最坏的情况不会出现．与其在union中随意将一棵树随意地链接到另外一颗，我们记录每棵树的大小，将较小的树连接到较大的树上（因为大树作为小树的子树会增加其深度）．

  1. 额外需要一个 *sz[]* 保存节点所在树的大小，初始化每个元素为１

  ```cpp
  //find函数不变
  void union(int p,int q){
  	int i = find(p);
  	int j = find(q);
  	if(i == j) return;
  	if(sz[i]<sz[j]){
  		id[i]=j;	sz[j] += sz[i];
  	}else{
  		id[j]=i;	sz[i] += sz[j];
  	}
  	count--;
  }
  ```

  

- **算法分析**

  当左右两棵树大小相同时，两棵树在根节点上合并只会增加１个节点深度．那么只要小树合并到大树则不会增加深度，使 *find()*始终具有对数复杂度，整个union函数也具有对数级别

### 习题

### 1.1.13 打印一个M行M列二维数组的转置

### 1.1.14 编写静态方法lg()，接受一个整型参数N，返回不大于logN的最大整数

### 1.1.20 编写一个递归的静态方法计算ln(N!)

### 1.1.26

### 1.1.28

### 1.1.35 模拟掷骰子

### 1.1.36 乱序检查



# 第二章 排序

## 选择排序

​	首先找到数组中最小的那个元素，其次将它和数组的第一个元素交换．再次，在剩下的元素中找最小元素，和数组的第二个元素进行交换．

```cpp
void selection(vector<int> a){
	for(int i = 0; i < a.size(); i++){
		int min = a[i];
		for(int j = i+1; j < a.size();j++){
			if(a[i]>a[j]) min = a[j]
		}
		swap(i,min);
	}
}
```

- 算法分析

  1. 运行时间和输入无关，数据移动是最少的

  2. 对于长度为Ｎ的数组，时间复杂度为*O(N^2)* .

     大约需要N^2/2次比较和Ｎ次交换



## 插入排序

​	当前索引左边的所有元素都是有序的，但它们的最终位置还不确定，为了给更小的元素腾出空间，它们可能会被移动，但是当索引到达数组的右端时，数组排序就完成了

​	与选择排序不同的是，插入排序所需的时间取决与输入中元素的初始顺序	

# 第三章 查找

# 第四章 图

# 第五章 字符串

# 第六章 数值

### 整数反转

LC 7

https://leetcode-cn.com/problems/reverse-integer/solution/zheng-shu-fan-zhuan-by-leetcode-solution-bccn/