# 第一章 基础

1. 使用管道与重定向读入与写出数据、

   ```java
   //使用>将输出重定向到data.txt，而不是直接打印到终端
   % java RandomSeq 1000 100.0 200.0 > data.txt、
   //使用<将文件输入
   % java Average < data.txt
   //使用 | 将Random的标准输出和Average的标准输入指定为同一个流
   % java RandomSeq 1000 100.0 200.0 | java Average
   ```

## 背包

- 一种**不支持从中删除元素**的集合数据类型，它的目的就是帮助用例收集元素并迭代遍历所有收集到的元素。*使用bag可以说明元素的处理顺序不重要。*

## 先进先出队列

- 应用：
  1. 排队问题：优先为等待最久的人或者说最先到达的人服务
  2. 文件读取：无需知道文件的大小，即可将文件的所有数据读入到一个数组中。首先将所有的数据的读入队列中，然后使用队列的size()成员得到数组的大小，从而创建数组并将队列中的所有整数移动到数组中。（由于队列能够按照数据在文件中的顺序放入数组中）

## 下压栈

- 应用：

  1. 网页访问：点击一个超链接时，浏览器会显示新的页面，同时将旧页面压入栈中，这样我们可以不断的点击超链接访问新的页面，也可以通过回退按钮重新访问以前的页面。

  2. 在用保存元素的同时颠倒它们的相对顺序

  3. 算数表达式求值

     - Dijkstra：用两个栈（一个保存运算符，一个保存操作数）

       1. 将操作数压入操作数栈
       2. 将运算符压入运算符栈
       3. 忽略左括号
       4. 在遇到右括号时弹出一个运算符，弹出其所需数量的操作数，并将运算结果压入操作数栈

       在处理完表达式后，操作数栈中只会有一个值，即为表达式的处理结果

## 链表

- 基于链表的栈实现

  将栈保存为一条链表，**栈顶即为表头**，使用一个指向链头的指针即可

  ```c++
  //position: /usr/include/c++/10/bits/stl_stack.h
  /**
     *  @brief  A standard container giving FILO behavior.
     *  @ingroup sequences
     *  @tparam _Tp  Type of element.
     *  @tparam _Sequence  Type of underlying sequence, defaults to deque<_Tp>.
     *  Meets many of the requirements of a
     *  <a href="tables.html#65">container</a>,
     *  but does not define anything to do with iterators.  Very few of the
     *  other standard container interfaces are defined.
     *  This is not a true container, but an @e adaptor.  It holds
     *  another container, and provides a wrapper interface to that
     *  container.  The wrapper is what enforces strict
     *  first-in-last-out %stack behavior.
     *
     *  The second template parameter defines the type of the underlying
     *  sequence/container.  It defaults to std::deque, but it can be
     *  any type that supports @c back, @c push_back, and @c pop_back,
     *  such as std::list, std::vector, or an appropriate user-defined
     *  type.
     *
     *  Members not found in @a normal containers are @c container_type,
     *  which is a typedef for the second Sequence parameter, and @c
     *  push, @c pop, and @c top, which are standard %stack/FILO
     *  operations.
    */
   template<typename _Tp, typename _Sequence = deque<_Tp> >
   class stack{
       typedef typename _Sequence::value_type _Sequence_value_type;
       public:
        typedef typename _Sequence::value_type		value_type;
        typedef typename _Sequence::reference			reference;
        typedef typename _Sequence::const_reference	const_reference;
        typedef typename _Sequence::size_type		    size_type;
        typedef	       _Sequence					container_type;
  	 protected:
        _Sequence c;
       template<typename _Seq = _Sequence, typename _Requires = typename
  	       enable_if<is_default_constructible<_Seq>::value>::type>
  	 stack(): c() { }
       explicit stack(const _Sequence& __c): c(__c) { }
       explicit stack(_Sequence&& __c): c(std::move(__c)) { }
       
  	 template<typename _Alloc, typename _Requires = _Uses<_Alloc>>
  	 explicit stack(const _Alloc& __a): c(__a) { }
  
       template<typename _Alloc, typename _Requires = _Uses<_Alloc>>
  	 stack(const _Sequence& __c, const _Alloc& __a): c(__c, __a) { }
  
       template<typename _Alloc, typename _Requires = _Uses<_Alloc>>
  	 stack(_Sequence&& __c, const _Alloc& __a): c(std::move(__c), __a) { }
  
       template<typename _Alloc, typename _Requires = _Uses<_Alloc>>
  	 stack(const stack& __q, const _Alloc& __a): c(__q.c, __a) { }
  
       template<typename _Alloc, typename _Requires = _Uses<_Alloc>>
  	 stack(stack&& __q, const _Alloc& __a): c(std::move(__q.c), __a) { }
       
       bool empty() const { return c.empty(); }
       size_type size() const { return c.size(); }
       reference top(){
  		__glibcxx_requires_nonempty();
  		return c.back();
       }
       void pop(){
  		__glibcxx_requires_nonempty();
  		c.pop_back();
       }
  
       void push(const value_type& __x){ c.push_back(__x); }
       void push(value_type&& __x) { c.push_back(std::move(__x)); }
       #if __cplusplus > 201402L
       template<typename... _Args>
  	 decltype(auto) emplace(_Args&&... __args){ return c.emplace_back(std::forward<_Args>(__args)...); }
  	 #else
       template<typename... _Args>
  	 void emplace(_Args&&... __args) { c.emplace_back(std::forward<_Args>(__args)...); }
       
       template<typename _Tp, typename _Seq>
       inline bool operator==(const stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y){ 
           return __x.c == __y.c; }
       
       template<typename _Tp, typename _Seq>
       inline bool operator!=(const stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y){ 
           return !(__x == __y); }
  ```

- 基于链表的队列实现

  ```c++
  //position: /usr/include/c++/10/bits/stl_queue.h
  //大部分操作与stack适配器相同
  template<typename _Tp, typename _Sequence = deque<_Tp> >
  class queue{
  	...
  	reference front(){
  		__glibcxx_requires_nonempty();
  		return c.front();
      }
      reference back(){
  		__glibcxx_requires_nonempty();
  		return c.back();
      }
      void
      push(const value_type& __x){	c.push_back(__x); }
  
      /**
         *  @brief  Removes first element.
         *
         *  This is a typical %queue operation.  It shrinks the %queue by one.
         *  The time complexity of the operation depends on the underlying
         *  sequence.
         *
         *  Note that no data is returned, and if the first element's
         *  data is needed, it should be retrieved before pop() is
         *  called.
         *　pop的时间复杂度取决于底层数据结构，返回值为空
         */
      void pop(){
  		__glibcxx_requires_nonempty();
  		c.pop_front();
       }
      ...
  }
  ```

  

# 习题

### 1.1.13 打印一个M行M列二维数组的转置

### 1.1.14 编写静态方法lg()，接受一个整型参数N，返回不大于logN的最大整数

### 1.1.20 编写一个递归的静态方法计算ln(N!)

### 1.1.26

### 1.1.28

### 1.1.35 模拟掷骰子

### 1.1.36 乱序检查



# 第二章 排序

# 第三章 查找

# 第四章 图

# 第五章 字符串

# 