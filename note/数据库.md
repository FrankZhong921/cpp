# SQL

## DQL语言



**数据查询语言**

### 子查询

- 子查询（或内查询）：出现在其它语句中的*select* 语句

- 主查询（或外查询）：相对于子查询的外部查询语句

- 分类

  - **按子查询出现的位置：**

    1. **select后面**：仅仅支持标量子查询

    2. **from后面**：支持表子查询

    3. **where 或 having后面**：支持标量子查询、列子查询、行子查询

       - 特点：

         1. **子查询放在小括号内**
         2. 子查询一般放在条件的右侧
         3. 标量子查询一般搭配**单行操作符，>  <   >=  <=  =  <>**
         4. 列子查询一般搭配**多行操作符，in  any/some  all**

       - 标量子查询

         ``` sql
         select * from employees where salary > (select salary from employees where last_name = 'Amen');
         
         select last_name, job_id, salary from employees where salary =(  select min(salary) from employees);
         
         #查询最低工资大于50号部门最低工资的部门id和其最低工资,having子句也可以子查询
         select min(salary), departmend_id from employees group by department_id having min(salary) > (select min(salary) from employees where department_id = 50);

       - 列子查询

       - 行子查询

    4. **exists后面**（相关子查询）：支持表子查询

       - 只关心子查询中是否有值，查询结果是布尔类型，只有1，0

         ```select exist(select department_id from employees)```

         ```sql
         #查询有员工的部门名
         select department_name from departments d where 
         exist(select * from employees e where e.department_id = d.department_ids);
         
         select department_name from departments where
         department_id in (select department_id from employees );
         ```

         

  - **按结果集的行列数不同：**

    1. 标量子查询（结果集只有一行一列）
    2. 列子查询（结果集只有一列多行）
    3. 行子查询（结果集有一行多列）
    4. 表子查询（结果集一般为多行多列）

  

### 分页查询

- 应用场景：

  淘宝商品页，比如搜索男装，可能有10000条数据，但是并不会将整个10000条商品信息在网页中全部显示出来，而是一次只显示一个页面，当我们点击下一页时，向服务器获取另外10条结果。

- 语法：使用 ***limit*** , offset表示起始索引（从零开始），size表示大小

  ```sql
  select 查询列表			 	  7
  from 表						1
  [join type] join 表2			2
  on 连接条件					  3
  group by 分组字段		      4
  having 分组后的筛选			 5
  order by 排序字段			  6
  limit offset,size; 			 8
  #offset = (page -1) * size
  ```

  - tip：对于得到最大值，最小值不一定需要用max, min，也可以通过排序+limit 1获取

### 联合查询

- union ： 将多条查询的语句的结果合并成一个结果，多表的行合并

- 语法：

  ```sql
  查询语句1
  union
  查询语句2
  union
  ...
  ```

- 应用场景：

  一个网站中多个数据库多个数据表，涉及查多个表，且多个表没有连接关系，将多表的查询结果进行合并。 **合并的前提：每个行的列数必须一致。建议(不报错)每一列对应的类型相同**

- **使用union联合查询默认去重，若不需要去重，使用union all**

## DML语言

**数据操作语言：**

### 插入

- 语法１：

  ```sql
  insert into 表名（列名......）
  values (值１...),
  (值２...),
  ...
  ```

  - 注：若插入完整行，则表明后面的列名列表可以省略

  - 若某个列字段允许为空，若表名后面的列名没有省略，则对应值为空必须为NULL，若省略了列名，则对应值可以省略．

    ```sql
    #列名列表省略
    insert into beauty
    values ('柳岩','女','121231414');
    #若性别可为空
    insert into beauty (name,phone)
    values ('柳岩','121231414');
    ```

  - 列名列表的顺序可以调换，但是对应值的位置必须一一对应．

- 语法２：

  ```sql
  #无需列名列表的写法
  insert into 表名
  set 列名＝值，列名＝值;
  ```

- 两种语法的比较

  1. **语法１支持一次插入多行**，语法２不支持

  2. **语法１支持子查询**，语法２不支持

     ```sql
     insert into beauty(id,name,phone)
     select 26,'舒淇'，'1551231515';
     #子查询1
     insert into beauty(id,name,phone)
     select id,boyname,'1241512415'
     from boys where id<3;
     
     #一次插入多行
     insert into beauty(id,name,phone)
     select 26,'舒淇','1551231515'
     union
     select 27,'周迅','1552131415';
     ```

     

### 修改

- 修改单表记录

  - 语法：

    ```sql
    update 表名
    set 列＝值,
    列＝值，
    ...
    where 条件
    ```

    

- 修改多表记录（级联修改）

  - 语法：

    ```sql
    update 表１　别名
    inner|left|right join 表２ 别名
    on 连接条件
    set 列＝值，列＝值,...
    where 筛选条件
    ```

  - ```SQL
    update boys bo
    inner join beauty b on bo.id = b.boyfriend_id
    set b.phone = '114'
    where bo.boyName = 'ASDA';		
    ```

    

### 删除

- 方法１：**delete**

  - 单表删除语法：

    ```sql
    delete from 表名　where 筛选条件;	
    ```

  - 多表删除语法：

    ```sql
    delete 别名1...(别名２)(别名１，别名２)
    from 表１　别名１
    inner | left|right join 表２　别名２
    on 连接条件
    where 筛选条件
    ```

    **注：要删除那个表中对应的记录，取决与delete后面的别名是那个表**

- 方法２：truncate

  - 语法：

    ```sql
    #整个表清空，不能加条件
    truncate table 表名;
    ```

- 方法１vs方法２

  1. delete 可以加where条件，truncate不能加条件;
  2. truncate删除，效率较高
  3. 假如要剔除的表中有自增长列，如果使用delete剔除后，再插入数据，自增长列的值从断点开始，而truncate剔除后，再插入数据．自增长列的值从１开始
  4. truncate删除没有返回值，delete删除有返回值．
  5. truncate删除不能回滚，delete删除可以回滚

## DDL语言

**数据定义语言**

创建：create  修改：alter　删除：drop

### 库的管理

- 创建

  ```sql
  create datebase 库名
  
  #但是如果该库已存在则会出现错误
  create database 库名　if not exists 库名;
  ```

  

- 修改

  ```sql
  #一般不修改库，不安全
  #更改库的字符集
  alter database 库名　character set gbk;
  ```

  

- 删除

  ```sql
  drop database 库名 if exists 库名;
  ```

  

### 表的管理

- 创建

  ```sql
  create table 表名(
  	列名　列的类型 [[长度],[约束]],
  	列名　列的类型 [[长度],[约束]],
  	...
  )
  ```

  

- 修改

  ```Sql
  #修改列名
  alter table 表名　change column 列名　新列名　类型;
  #修改列的类型
  alter  table 表名 modify column 列名　新类型;
  #添加新列
  alter table 表名　add column 新列名　新类型;
  #删除列
  alter table 表名　drop column 列名;
  #修改表名
  alter table 表名　rename to 新表名;
  ```

  

- 删除

  ```sql
  drop table if exists 表名;　#跟drop database 库名 if exists 库名
  show tables;　#显示库中所有表
  ```

- 复制

  ```sql
  #仅仅复制表的结构
  create table 表名 like 参考表名;
  
  #复制表的结构+数据
  create table 表名 select * from author;
  
  #仅仅复制某些结构字段，不要数据(筛选条件不满足即可)
  create table 表名 select 某些字段 from 参考表名　where 0;
  
  ```

  注：跨库查询 from 后面使用　库名.表名 即可．

## 基本数据类型

- 数值型：

  - 整数：Tinyint(8 ) , Smallint(16), Mediumint(24), Int(32), BIgInt(64)

    ```sql
    #整数默认有符号
    #设置无符号
    create table 表名(
    	列名 int unsigned；
    )
    #如果超出表示范围出错　
    #对于整数后面的长度，只表示显示的长度，不表示实际的大小,并且使用zerofill默认无符号
    create table 表名(
    	列名　int(7) zerofill unsigned;
    )
    ```

    

  - 小数：**Ｍ和Ｄ，Ｄ是小数点后保留Ｄ位，整数位为M-D 位，如果超出范围，则插入临界值9999填补**

    - 浮点型：float(M,D), double(M,D)，根据插入数值决定精度
    - 定点型：dec(M,D), decimal(M,D)，默认M=10，D=0

- 字符型：**Ｍ表示最多的字符数，不是最多的字节数**

  - 较短文本：char \ varchar，char表示固定长度的字符，varchar可变

  但char的效率高一点，varchar虽然节省空间，但效率低一些

  - 较长文本：text  \ blob（较长的二进制数据）
  - 其他：binary,varbinary,enum,set,

- 日期型：

  - data(4,日期), datetime(8,日期+时间), timestamp(4，自1970年的秒数), time(3), year(1)

  - date范围(1000 - 9999)，不受时区影响

    timestamp(1970 - 2038)，受时区影响

    ```sql
    #显示时区
    show variables like 'time_zone';
    #修改时区
    set time_zone = '+9:00';
    ```


## 约束

含义：一种限制，用于限制表中的数据，为了保证表中的数据的准确和可靠性，**有列级约束(六大约束都能添加，但外建约束没有效果)和表级约束(写在最后，除了非空，默认，其他都支持)**

```sql
create table 表名(
	字段名　字段类型　列级约束,
	字段名　字段类型,
	表级约束
)
```



1. not null
2. default：默认，用于保证该字段有默认值
3. primary key：主键，保证该字段值唯一且不能为空
4. unique：保证该字段值唯一，但可以为空
5. check：检查约束（mysql不支持，限制字段的取值）
6. foreign key：外键，用于限制两个表的关系，在从表中添加外建约束，用于引用主表中某列的值．保证从表的该字段的值必须来源于主表中存在的g

```sql
create table stuinfo(
	id int primary key,							#主键
	stuname varchar(20) not null,				#非空
	gender char(1) check(gender in ('男','女')), #检查约束
	seat int unique,							#唯一
	age int default 18,							#默认
	majorId int foreign key references major(id)#外键约束
);
```

- **主键vs唯一**：主键不为空，唯一可为空(且null也是唯一)；

  一个表只能有一个主键，唯一可多个；

  主键支持多个字段值组合，唯一也可以支持多字段组合

- **外键**：要求在从表中设置外键关系；

  从表的外键列的类型和主表关联列的类型要求一致或兼容，名称无要求；

  **主表的关联列必须是一个key（一般是主键或唯一）;**

  插入数据时，先插入主表，再插从表；删除数据，先删从表，再删主表

  
  
  

## 标识列

可以不用手动插入值，由系统默认提供.

```sql
show variables like 'auto_increament' #可显示表示列的属性信息
#结果出现
#auto_increment_increment　自增长的步长
#auto_increment_offset		自增长的起始

#修改步长
set auto_increment_increment = 3; 
```

- 创建表时设置标识列

  ```sql
  create table 表名(
  	id int primary key auto_increment,
  	name varchar(20)
  );
  insert into 表名 values(null, 'john');
  ```

- 修改表时设置标识列

  ```sql
  alter table 表名 modify column 列名　int auto_increment;
  ```

- 修改表时删除标识列

  ```sql
  alter table 表名　modify column 列名 int;
  ```



- 特点：

  - 标识符**不一定和primary key搭配，是键(唯一，外键)都行**
  - 一个表只能有１个标识列
  - 标识列的类型只能是**数值型**
  - 可以通过set设置步长，也可手动插入值设置起始

  

## 事务

Transaction Control Language 事务控制语言

一个或一组sql语句组成一个执行单元，这个执行单元**要么全部执行，要么全部不执行．**执行失败，整个事务回滚，回到初状态

```show engines```可以显示mysql支持的存储引擎，用的最多的有：innodb, myisam, memory等，其中*innodb* 支持事务，而 *myisam*,*memory* 不支持事务．



### 事务的ACID属性

1. 原子性（Atomicity）:事务是一个不可分割的工作单位，要么发生要么不发生．
2. 一致性（Consistency）：事务必须使数据库从一个一致性状态变换为另一个一致性状态使用
3. 隔离性（Isolation）：一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰（**很多时候需要隔离级别实现**）
4. 持久性（Durability）：一个事务一旦**提交**，对数据库的改变就是永久性的，接下来的其他操作或数据库故障不应对其有影响．

### 事务的创建

- 隐式事物：事务没有明显的开始和结束的标记，比如insert,update,delete

  ```sql 
  show variables like 'autocommit'; #自动提交　on 开启
  ```

- 显式事务：**必须先设置自动提交功能为禁用**

  ```sql
  set autocommit = 0;	#只针对当前会话有效
  ```

  - 步骤１：开启事务
  - 步骤２：编写事务中的sql语句(select, insert, update, delete)
  - 步骤３：结束事务（commit;提交事物，rollback;回滚）

  ```sql
  # 1
  set autocommit = 0;
  start transaction;#这句也可不加
  # 2
  update account set balance 
  # 3
  [rollback] [commit];
  
  ```

  ### 事务的并发问题

  **如果同时运行的多个事务，当这些事务访问数据库中相同的数据时，没有采取隔离机制，就会导致各种并发问题．**

- **脏读**：一个事务Ａ修改数据，但还没有提交，另外一个事务Ｂ读取了修改后的值，若Ａ将事务回滚，则Ｂ出现脏读．
- **不可重复读**：事务Ａ读取了一个字段，之后事务Ｂ对其进行更新并提交，事务Ａ还未提交，此时再读一次结果又不同了．
- **幻读**：一个事务Ａ读取了一个字段，另外一个事务Ｂ插入一些新的行并提交，之后Ａ在事务结束之前又读取了同一个表，此时多出了几行

这些错误，是在事务执行过程中发生的．

### 事务的隔离级别

四种隔离级别

- **Read uncommited(读未提交数据)**

  允许事务读取未被其他事务提交的更新，会出现脏读，不可重复读，幻读

- **Read commited(读已提交数据)**

  只允许事务读取已经被其他事务提交的变更，**可以避免脏读**，其他仍会出现

- **Repeatable read(可重复读)**

  确保事务可以**多次**从一个字段中读取相同的值，但这个事务执行过程中禁止其他事务对这个字段进行更新，**可以避免脏读不可重复读**，但仍会出现幻读

- **Serializable(串行化)**

  可以从一个表中读取相同的行，在整个事务持续期间，禁止其他事务对该表执行插入，更新和删除操作．能避免并发问题，但性能很低，阻塞

```sql
#查看默认隔离级别
select @@tx_isolation;
#设置隔离级别(mysql默认repeatable read,oracle 默认read commited)
set session transaction isolation level read uncommitted;
set session transaction isolation level read committed;
set session transaction isolation level repeatable read;
set [session|global] transaction isolation level serializable;


```

**设置保存点**

```sql
set autocommit = 0;
start transaction;
delete from account where id = 25;
savepoint a; #搭配rollback使用,回滚到保存点
delete from account where id = 28;
rollback;
```

## 存储过程

- 含义：一组预先编译好的SQL语句集合，理解成批处理语句

  1. 提高代码重用性
  2. 简化操作
  3. 减少了编译次数并且减少了和数据库的连接次数，提高了效率

- 创建语法

  ```sql
  #需要先设置结束符，因为若以;作为存储过程的结束符，而存储过程内的语句也以；分隔，则产生歧义  
  #使用$作为结束符，这一句不能以；结束，否则是以　$; 作为结束符
  delimiter $
  create procedure 过程名 (参数列表)
  begin
  	#一组sql操作;
  end$
  
  
  ```

  其中对于参数列表，与函数不同，返回值也是在参数列表中声明，使用参数模式，因此参数列表中每一项由参数模式，参数名和参数类型组成．

  - 参数模式：　in , out , inout

  ```sql
  #举例
  in stuname varchar(20)
  ```

  如果存储过程体仅仅有一句话，*begin* 和 *end* 可以省略，**存储过程体中的每条sql语句**的结尾必须加分号，**存储过程的结尾可以使用*delimiter* 重新设置．** 并且由于设置了delimiter，除非重新设为分号，否则后面的sql语句都需要用$

- 调用语法

  ```sql
  call 存储过程名(实参列表);
  ```

- 删除语法

  ```sql
  drop procedure 存储过程名;#只能删除一个
  ```

- 查看语法

  ```sql
  #不能使用desc
  show create procedure 存储过程名;
  ```

  

- 案例

  - 空参列表

    ```sql
    #插入到admin表中五条记录
    delimiter $
    create procedure myp1()
    begin
    	insert into admin (usrname, password) values
    	('john1','0000'),('lily','1111'),('Tom','2222'),('Toby','4444'),('Tina','5555');
    end $
    call myp1()$
    ```

  - 带in参数模式的列表

    ```sql
    #创建存储过程实现，用户是否登录成功
    create procedure myp2(in username varchar(20), in password varchar(20))
    begin
    	declare result int default 0;	#声明变量
    	select count(*) into result		#判断是否有该用户名和密码对应的条目，若为０则失败
    	from admin
    	where admin.username = username
    	and admin.password = password;
    	select if(result >0 ,'成功','失败');
    end $
    ```

  - 带out参数模式的列表

    ```sql
    #根据女神名，输出她的男朋友及魅力值
    create procedure myp3(in beautyName varchar(20),out boyName varchar(20),out userCP int)
    begin 
    	select bo.boyName, bo.userCP into boyName,userCP	#将数据传入变量！
    	from boys bo
    	inner join beauty b on bo.id = b.boyfriend_id
    	where b.name = beautyName;
    end$
    ```

  - 带inout参数模式的列表

    ```sql
    #传入a,b两个值，最终a和b都翻倍并返回
    create procedure myp8(inout a int, inout b int)
    begin 
    	set a = a*2;
    	set b = b*2;
    end$
    
    #调用
    set @m = 10$
    set @b = 20$
    call myp8(@m,@n)$
    select @m,@n $
    ```

  - ```sql
    create procedure cmpdate (in birth1 datetime, in birth2 datetime, out result int)
    begin
    	select datediff(birth1,birth2) into result;
    end$
    ```

  - ```sql
    #创建一个存储过程，实现传入一个日期，格式化为xx年yy月zz日
    create procedure date_format(in mydate datetime , out str varchar(50))
    begin 
    	select date_format(mydate,'%y年%m月%d日') into str;
    end$
    ```

    **字符转日期　str_to_date    ,   日期转字符　date_format**

  - ```sql
    #传入女神名，返回：'女神　and 男神' 格式的字符串
    create procedure test_pro5(in beautyName varchar(20), out str varchar(50))
    begin
    	select concat(beautyName,'and',ifnul(boyName,'null')) into str
    	from boys bo
    	right join beauty b 
    	on b.boyfriend_id = bo.id
    	where b.name = beautyName
    end$
    ```

## 函数

- 创建语法

  ```sql
  create function 函数名(参数列表) returns 返回类型
  begin
  	函数体
  end
  ```

  注意：参数列表包含两个部分：参数名　参数类型（不再有参数模式）

  ​			函数体中必有return语句，如果没有则会报错

  ​			若函数体中只有一句话则可以省略return

  ​			同样使用 *delimiter* 设置结束标记

- 调用语法

  ```sql
  #不是使用call !!! 使用select
  select 函数名(参数列表)
  ```

- 查看函数

  ```sql
  show create function 函数名;
  ```

- 删除语法

  ```sql
  drop function 函数名;
  ```

- 案例

  - 无参有返回

    ```sql
    ＃返回公司的员工人数
    create function myf1() return int
    begin
    	declare c int default 0;
    	select count(*) into c
    	from employees;
    	return c;
    end $
    ```

  - 有参有返回

    ```sql
    #根据员工名，返回它的工资
    create function myf2(empName varchar(20)) returns double
    begin
    	set @sal = 0;
    	select salary into @sal
    	from employees
    	where last_name = empName;
    	return @sal;
    end$
    ```

## 流程控制结构

1. 顺序结构：程序从上到下依次执行
2. 分支结构：程序从两条或多条路径中选择一条去执行
3. 循环结构：程序在满足一定条件的基础上，重复执行的一段代码

### 分支结构

- if函数

  - 功能：实现简单的双分支

  - 语法：

    ```sql
    if(表达式１,表达式２,表达式３)
    #如果表达式１成立，则返回表达式２的值，否则返回表达式３的值
    ```

- case结构

  - 情况１：类型swtich语句，一般用于实现等值判断

    - 语法

      ```sql
      case 变量｜表达式｜字段
      when 要判断的值 then 返回的值１或语句１;
      when 要判断的值 then 返回的值２或语句２;
      ...
      else 要返回的值n或语句n;
      end case;
      ```

      

  - 情况２：类似多重if语句，一般用于实现区间判断

    - 语法

      ```sql
      case 
      when 要判断的条件１ then 返回的值１或语句1;
      when 要判断的条件２ then 返回的值２或语句2;
      ...
      else 要返回的值n或语句n;
      end case;
      ```

  - 特点：

    1. 可以作为表达式，嵌套在其他语句中在使用，可以放在任何地方，begin　end中或外

       可以作为独立的语句去使用，此时只能放在begin end中

    2. 如果when中的值或者条件成立，则执行对应then后面的语句，并且结束case

       如果都不满足则执行else中的语句或值

    3. else可以省略，如果else省略了，并且所有when条件都不满足，则返回null


  - 案例：

    ```sql
    #根据传入的成绩，来显示等级
    create procedure tesr_case(in score int)
    begin
    	case
    	when score >= 90 and score <= 100 then select 'A';
        when score >= 80 then select 'B';
        when score >= 60 then select 'C';
        else select 'D';
        end case
    end$
    ```

- **if 结构**

  - 功能：实现多重分支

  - 语法：

    ```sql
    if 条件１ then 语句１;
    elseif 条件２	then 语句２;
    ...
    else 语句n
    end if;
    ```

  - 特点：应用在　begin 和　end中

  - 案例：

    ```sql
    create procedure test_if(score int) returns char
    begin
    	if score >= 90 and score <= 100 then return 'A';
    	elseif score >= 80 then return 'B';
    	elseif score >= 60 then return 'C';
    	else return 'D';
    	end if;
    end$
    ```

### 循环结构

- 分类：while（先判断后执行）, loop（先执行后判断）, repeat（没有条件的死循环）

- 循环控制：　iterate类似　continue，继续

  ​						leave类似	break，打断

- while

  - 语法：

    ```sql
    [标签：]　while 循环条件 do
    		循环体
    		end while [标签];
    ```

  - 案例

    ```sql
    create procedure pro_while1(in insertCount)
    begin
    	declare i int default 1;
    	a: while i<= insertCount do
    		insert into admin(username,password) values (concat('john',i),'0000');
    		if　i >= 20 then leave a;
    		end if;
    		set i = i + 1;
    	   end while a;
    end $
    ```

    ```sql
    create procedure test_while1(in insertCount int)
    begin
    	declare i int default 0;
    	a: while i <= insertCount do
    		set i = i + 1;
    		if mod(i,2) != 0 then iterate a;
    		end if;
    		insert into admin(username , password) values (concat('john',i),'0000');
    		end while a;
    end$
    call test_while(100)$
    ```

    ```sql
    #产生随机字符串
    delimter $
    create procedure test_randstr_insert(in insertCount int)
    begin
    	declare i int default 1;
    	declare srt varchar(26) default 'abcdefghijklmnopquvwxyz';
    	declare startIndex int default 1;
    	declare len int default 1;
    	while i <= insertCount do
    		set startIndex = floor(rand() * 26 + 1);#rand()产生无限接近１的值
    		set len = floor(rand() * (20 - startIndex + 1) + 1);　#为什么是20而不是26，因为varchar(20)
    		insert into stringcontent(content) values(substr(str,startIndex,len));#在26个字母中随机截取
    		set i = i +1;
    	end while;
    end $
    ```

    

- loop

  - 语法

    ```sql
    [标签：]　loop
    		循环体
    		end loop [标签];
    #可以用来模拟简单的死循环
    ```

- repeat

  - 语法

    ```
    [标签：] repeat
    		循环体
    		until 结束循环的条件
    		end repeat [标签];
    ```

    

#  MySql高级

## Linux安装mysql

- 判断是否安装成功

  ```shell
  //需要用户组的相关知识
  cat /etc/passwd | grep mysql
  car /etc/group | grep mysql
  //或者使用--version
  ```

- 设置开机启动

  ```shell
  chkconfig mysql on
  chkconfig --list | grep mysql
  ```
  
  ````shell
  cat /etc/inittab
  #Default runlevel. The runlevels used by RHS are:
  #	0 - halt(Do Not set initdefault to this)
  #	1 - Single user mode	
  #	2 - Multiuser, without NFS(The same as 3)
  #	3 - Full multiuser mode
  #	4 - unused
  #	5 - X11
  #	6 - reboot (Do Not set initdefault to this)
  ````
  
  



## 配置文件

| 路径              | 解释                      | 备注                             |
| ----------------- | ------------------------- | -------------------------------- |
| /var/lib/mysql    | mysql数据库文件的存放路径 | /var/lib/mysql/atguigu/cloud.pid |
| /usr/share/mysql  | 配置文件目录              | mysql.server命令及配置文件       |
| /etc/init.d/mysql | 启停相关脚本              |                                  |

- 修改字符集和数据存储路径

  ```
  //添加下面三行
  character_set_server = utf8
  character_set_client = utf8
  collation-server = utf8_general_ci
  ```

- 主要配置文件

  - 二进制日志log-bin：主从复制
  - 错误日志log-error
  - 查询日志log
  - 数据文件

    - linux下/var/lib
    - frm文件：存放表结构framework
    - myd文件：存放表数据data
    - myi文件：存放表索引index

## mysql架构

链接曾－>业务逻辑层－>存储引擎层－＞存储层

1. 链接层

   最上层是一些客户段和连接服务，包含本地sock通信和大多数基于C/S端工具实现的类型tcp/ip的通信．主要完成一些类似于连接处理，授权认证，及相关的安全方案，在该层上引入了线程池的概念，为通过认证安全介入的客户端提供线程，同样在该层上可以实现基于SSL的安全连接，服务器也会为安全接入的每个客户端验证它所具有的操作权限．

2. 服务层

   第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化及部分内置函数的执行，所有跨存储引擎的功能也是在这一层实现，如函数，过程等．在该层，服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化如确定查询表的顺序，是否利用索引等，最后生成相应的执行操作，如果是select语句，服务器还会查询内部的缓存，如果缓存空间足够大，这样在解决大连读操作的环境中能够很好的提高系统的性能．

3. 引擎层

   存储引擎层，存储引擎真正的负责了Ｍysql中数据的存储和提取，服务器通过API与存储引擎进行通信，不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取，如MyISAM和InnoDB

4. 存储层

   数据存储层，主要是见数据存储在运行于裸设备的文件系统之上，并完成与存储引擎的交互．

   ```sql
   show variables like '%storage_engine%';
   #default_storage_engine		InnoDB
   #storage_engine				InnoDB
   ```

   

   | 对比项   | ＭyISAM                                            | InnoDB                                                       |
   | -------- | -------------------------------------------------- | ------------------------------------------------------------ |
   | 主外键   | 不支持                                             | 支持                                                         |
   | 事务     | 不支持                                             | 支持                                                         |
   | 行表锁   | 表锁，即使操作一条记录也会锁住整个表，不适合高并发 | 行锁，操时只锁某一行，不对其他行有影响，适合高并发           |
   | 缓存     | 只缓存索引，不缓存真实数据                         | 不仅缓存索引还缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响 |
   | 表空间   | 小                                                 | 大                                                           |
   | 关注点   | 性能                                               | 事务                                                         |
   | 默认安装 | Ｙ                                                 | Ｙ                                                           |

   

- 与其他数据库相比，MySql有点与众不同，它的架构可以在多种不同场景中应用并发挥良好的作用，主要体现在存储引擎的架构上．

- **插件式的存储引擎架构将查询处理和其他的系统任务以及数据的存储提取相分离**，这种架构也可以根据业务的需求和实际需要选择合适的存储引擎．

- Percona公司为Ｍysql数据库服务器进行了改进，在功能和性能上较Ｍysql有着显著的提升，提升了高并发下InnoDB的性能，开发了一款存储引擎xtradb可以完全替代InnoDB，被早期的阿里采用，后推出AliSql+AliRedis

- 根据流程图应该知道sql出问题时应该定位在哪一层，sql变慢，索引失效应该定位到业务逻辑层optimizer




## sql执行慢

**执行慢主要由两个时间决定**

- 执行时间长
- 等待时间长

**性能下降可能的原因**

- 查询语句写的烂：创建索引，使用子查询
- 索引失效：用了索引，但是失效，通常是mysql内部优化
- 关联查询太多join(设计缺陷或不得已的需求)
- 服务器调优及各个参数设置(缓冲，线程数等)

### sql Joins

自行脑补画面

- A和B交集

  ```sql
  select * from A inner join B on A.aid = B.nid;
  ```

- A的独有+ＡＢ交集

  ```sql
  select * from A left join B on A.aid = B.bid;
  ```

  由于使用外连接，Ａ独有的，即Ａ.aid没有和Ｂ.bid对应的，因此一行中Ｂ的那部分全部为null

- Ｂ的独有+ＡＢ交集

  ```sql
  select * from A right join B on A.aid = B.bid;
  ```

- A的独有

  ```sql
  select * from A left join B on A.aid = B.bid where B.bid = null;
  ```

- B的独有

  ```sql
  select * from A right join B on A.aid = B.bid where A.aid = null;
  ```

- A和Ｂ并集

  ```sql
  select * from A left join B on A.aid = B.bid
  union
  select * from A right join B on A.aid = B.bid;
  ```

- A和Ｂ并集去除交集（Ａ和Ｂ各自独有的）

  ```sql
  select * from A left join B on A.aid = B.bid where B.bid = null
  union
  select * from A right join B on A.aid = B.bid where A.aid = null;
  ```

  

### SQL解析顺序

from -> join ->on -> where -> group by -> having ->select -> order by -> limit

## 索引

- 什么是索引？

  官方：索引是帮助Mysql高效获取数据的数据结构

  因此，索引是一种数据结构，一种＂**排好序的快速查找数据结构**＂

  - **索引会影响到where后面的查找条件和order by 的排序**

  在数据库之外，还维持这满足特定查找算法的数据结构，这些数据结构以某种方式引用(指向)数据．这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是**索引**．通过会维护**BTree**

- 索引的优势

  1. 提高数据检索的效率，降低数据库的IO成本
  2. 通过索引对数据进行排序，降低数据排序的成本，降低了cpu的消耗

- 索引的劣势

  1. 实际上索引也是一张表，这表保存了主键和索引字段，并指向实体表的记录，所以索引列也是要占用空间的
  2. 虽然索引提高了查询速度，但同时也会降低更新表的速度，如对表进行insert, update和delete时不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段．
  3. 索引只是提高效率的因素之一，如果Mysql有大量数据的表，需要花时间建立最优秀的索引

- 语法

  - 创建

    ```sql
    select * from user where name = 'John';
    #为了select速度更快，创建单值索引
    create index 索引名(通常可以使用idx_表名_字段的格式) on 表名(字段)
    create index idx_user_name on user(name);
    
    #也可创建复合索引
    create index idx_user_name_email on user(name,email);
    
    #alter语法
    alter 表名　add [unique] index 索引名　on 表名(字段);
    ```

  - 删除

    ```sql
    drop index 索引名 on 表名;
    ```

  - 查看

    ```sql
    show index from 表名;
    ```

  - 使用alter命令

    ```sql
    alter table 表名　add primary key(字段名);	　#添加主键约束
    alter table 表名　add unique 索引名(字段名);		#添加唯一索引
    alter table 表名　add index 索引名(字段名);		#添加普通索引
    alter table 表名　add fulltext 索引名(字段名);	#添加全文索引
    ```

- 索引分类：单值索引，唯一索引，复合索引(一个索引包含多个列)



- 那些情况需要创建索引？
  1. 主键自动创建唯一索引
  2. 频繁作为查询条件的字段应该创建索引
  3. 查询中与其他表关联的字段，外键关系创建索引
  4. 频繁更新的字段不适合创建索引
  5. where条件里用不到的字段不创建索引
  6. 单键/复合索引的选择问题（高并发选择复合）
  7. 查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度
  8. 查询中统计或者分组字段
- 哪些情况下不需要创建索引？

  1. 表的记录太少
  2. 经常增删改的表：因为需要相应修改索引文件
  3. 如果某个字段含有大量重复值则无需创建
     - 索引的选择性是指索引列中不同值的数目与表中记录个数的比

## 性能分析

1. MySql Query Optimizer
2. MySql常见瓶颈
3. Explain



- MySql Query Optimizer																			

  1. MySql中有专门负责优化select语句的优化器模块，主要功能：通过分析计算系统中收集到的统计信息，为客户端请求的Query提供**它认为最优**的执行计划．
  2. 客户端向MySql请求一条Query，命令解析器模块完成请求分类，区别出是select并转发给MySql Query Optimizer时，MySql Query Optimizer首先会对整条Query进行优化，处理掉一些常量表达式的预算．直接换算成常量值，并对Query中的查询条件进行简化和转换，如去掉一些无用或显而易见的条件，结构调整等，然后分析Query中Hint信息（如果有）,看显示Hint信息是否可以完全确定该ｉQuery的执行计划，如果没有Hint或Hint信息还不足以完全确定执行计划，则会读取所涉及对象的统计信息，根据Query进行写相应的分析计算，然后再得出最后的执行计划．

- MySql常见瓶颈

  1. CPU：在CPU饱和的时候发生在数据装入内存或从磁盘上读取数据时
  2. IO：磁盘I/O瓶颈发生在装入数据远大于内存容量的时候
  3. 服务器硬件的性能瓶颈：top,free,iostat和vmstat来查看系统的性能状态

- Explain

  - 是什么

    | id   | select_type | table | type | possible_keys | key  | key_len | ref  | rows | extra |
    | ---- | ----------- | ----- | ---- | ------------- | ---- | ------- | ---- | ---- | ----- |

  - 能干嘛

    - 表的读取顺序
    - 数据读取操作的操作类型
    - 哪些索引可以使用
    - 哪些索引被实际使用
    - 表之间的引用
    - 每张表有多少行被优化器查询

  - 怎么用

  - 各字段解释

    - id：如果是子查询id会递增，**id越大的优先级越高**，越先执行；**同id值，按从上到下的顺序依次执行**

    - select_type：主要用于区别是普通查询，联合查询，子查询等

      | id   | select_type                                                  |
      | ---- | ------------------------------------------------------------ |
      | 1    | SIMPLE，简单的查询，不包含子查询或者UNION                    |
      | 2    | PRIMARY，查询中若包含任何复杂的子部分，最外层查询则被标记PRIMARY |
      | 3    | SUBQUERY，在select或where列表中包含了子查询                  |
      | 4    | DERIVED，在from后面的子查询，mysql会递归执行这些子查询并把结果存入临时表 |
      | 5    | UNION，若第二个select出现在union之后则标为UNION，若union在from后的子查询中，外层select标为DERIVED |
      | 6    | UNION RESULT，从UNION表获取结果的select                      |

      

    - table：查询用的是哪张表，**其中 *derived* 表示衍生表，其后面的数字是id字段的值**

    - type：显示查询使用了何种类型

      - 从最好到最差依次是（仅列举常见类型）：

        **system > const > eq_ref > ref > range > index > all**

      - | system | 表只有一行记录(等于系统表)，这是const类型的特例，不常见      |
        | ------ | ------------------------------------------------------------ |
        | const  | 表示通过索引一次就找到了,const用于比较primary key或unique，如将主键置于where列表这种，mysql就能将该查询转换为一个常量． |
        | eq_ref | 唯一性索引扫描，对于每个索引键，表中都只有一条记录与其对应   |
        | ref    | 非唯一性索引扫描，对于一个索引键有多条记录                   |
        | range  | 只检索给定范围的行，一般就是在where语句后出现between, <, >, in等 |
        | index  | Full Index Scan，Index与ALL区别为index类型只遍历索引树       |
        | all    | Full Table Scan，全表扫描                                    |

        **一般来说，要保证查询至少到达range级别，最好能到ref．**

    - possible_keys和key：可能会出现的索引和结果一定出现的索引

    - key_len：表示索引最大可能使用的字节数，根据定义计算得到的，不丢失精度下越小越好

    - ref：显示索引的哪一列被使用了，如果可能的话，是一个常数．哪些列或常量被用于查找索引列上的值

    - rows：找到匹配结果可能需要查找的行数

    - extra：额外信息

      - | using filesort               | 说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取．ＭySql中无法利用索引完成的排序操作称为"文件排序" |
        | ---------------------------- | ------------------------------------------------------------ |
        | using temporary              | 使用了临时表保存中间结果，ＭySql在对查询结果排序时使用临时表．常见于排序order by和分组查询group by |
        | using index                  | 如果同时出现using where，表明索引被用来执行索引键值的查找    |
        | using where                  | 如果没有同时出现using where，表明索引用来读取数据而非执行查找动作 |
        | using join buffer            | 使用了连接缓存，此时可适当增加缓存大小                       |
        | impossible where             | where总是false，例如where name ='a' and name = 'c'，不可能同时满足 |
        | select tables optimized away | 在没有group by 子句的情况下，基于索引优化MAX/MIN操作或者对于MyISAM存储引擎优化count(*)操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化． |
        | distinct                     | 优化distinct操作，在找到第一个匹配的元组后即停止找同样值的动作． |

        

  - 热身case



## mysql布



