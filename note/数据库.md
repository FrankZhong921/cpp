# SQL

## DQL语言

### 子查询

- 子查询（或内查询）：出现在其它语句中的*select* 语句

- 主查询（或外查询）：相对于子查询的外部查询语句

- 分类

  - **按子查询出现的位置：**

    1. **select后面**：仅仅支持标量子查询

    2. **from后面**：支持表子查询

    3. **where 或 having后面**：支持标量子查询、列子查询、行子查询

       - 特点：

         1. **子查询放在小括号内**
         2. 子查询一般放在条件的右侧
         3. 标量子查询一般搭配**单行操作符，>  <   >=  <=  =  <>**
         4. 列子查询一般搭配**多行操作符，in  any/some  all**

       - 标量子查询

         ``` sql
         select * from employees where salary > (select salary from employees where last_name = 'Amen');
         
         select last_name, job_id, salary from employees where salary =(  select min(salary) from employees);
         
         #查询最低工资大于50号部门最低工资的部门id和其最低工资,having子句也可以子查询
         select min(salary), departmend_id from employees group by department_id having min(salary) > (select min(salary) from employees where department_id = 50);

       - 列子查询

       - 行子查询

    4. **exists后面**（相关子查询）：支持表子查询

       - 只关心子查询中是否有值，查询结果是布尔类型，只有1，0

         ```select exist(select department_id from employees)```

         ```sql
         #查询有员工的部门名
         select department_name from departments d where 
         exist(select * from employees e where e.department_id = d.department_ids);
         
         select department_name from departments where
         department_id in (select department_id from employees );
         ```

         

  - **按结果集的行列数不同：**

    1. 标量子查询（结果集只有一行一列）
    2. 列子查询（结果集只有一列多行）
    3. 行子查询（结果集有一行多列）
    4. 表子查询（结果集一般为多行多列）

  

### 分页查询

- 应用场景：

  淘宝商品页，比如搜索男装，可能有10000条数据，但是并不会将整个10000条商品信息在网页中全部显示出来，而是一次只显示一个页面，当我们点击下一页时，向服务器获取另外10条结果。

- 语法：使用 ***limit*** , offset表示起始索引（从零开始），size表示大小

  ```sql
  select 查询列表			 	  7
  from 表						1
  [join type] join 表2			2
  on 连接条件					  3
  group by 分组字段		      4
  having 分组后的筛选			 5
  order by 排序字段			  6
  limit offset,size; 			 8
  #offset = (page -1) * size
  ```

  - tip：对于得到最大值，最小值不一定需要用max, min，也可以通过排序+limit 1获取

### 联合查询

- union ： 将多条查询的语句的结果合并成一个结果，多表的行合并

- 语法：

  ```sql
  查询语句1
  union
  查询语句2
  union
  ...
  ```

- 应用场景：

  一个网站中多个数据库多个数据表，涉及查多个表，且多个表没有连接关系，将多表的查询结果进行合并。 **合并的前提：每个行的列数必须一致。建议(不报错)每一列对应的类型相同**

- **使用union联合查询默认去重，若不需要去重，使用union all**

## DML语言

数据操作语言：

### 插入

- 语法１：

  ```sql
  insert into 表名（列名......）
  values (值１...),
  (值２...),
  ...
  ```

  - 注：若插入完整行，则表明后面的列名列表可以省略

  - 若某个列字段允许为空，若表名后面的列名没有省略，则对应值为空必须为NULL，若省略了列名，则对应值可以省略．

    ```sql
    #列名列表省略
    insert into beauty
    values ('柳岩','女','121231414');
    #若性别可为空
    insert into beauty (name,phone)
    values ('柳岩','121231414');
    ```

  - 列名列表的顺序可以调换，但是对应值的位置必须一一对应．

- 语法２：

  ```sql
  #无需列名列表的写法
  insert into 表名
  set 列名＝值，列名＝值;
  ```

- 两种语法的比较

  1. **语法１支持一次插入多行**，语法２不支持

  2. **语法１支持子查询**，语法２不支持

     ```sql
     insert into beauty(id,name,phone)
     select 26,'舒淇'，'1551231515';
     #子查询1
     insert into beauty(id,name,phone)
     select id,boyname,'1241512415'
     from boys where id<3;
     
     #一次插入多行
     insert into beauty(id,name,phone)
     select 26,'舒淇','1551231515'
     union
     select 27,'周迅','1552131415';
     ```

     

### 修改

- 修改单表记录

  - 语法：

    ```sql
    update 表名
    set 列＝值,
    列＝值，
    ...
    where 条件
    ```

    

- 修改多表记录（级联修改）

  - 语法：

    ```sql
    update 表１　别名
    inner|left|right join 表２ 别名
    on 连接条件
    set 列＝值，列＝值,...
    where 筛选条件
    ```

  - ```SQL
    update boys bo
    inner join beauty b on bo.id = b.boyfriend_id
    set b.phone = '114'
    where bo.boyName = 'ASDA';		
    ```

    

### 删除

- 方法１：**delete**

  - 单表删除语法：

    ```sql
    delete from 表名　where 筛选条件;	
    ```

  - 多表删除语法：

    ```sql
    delete 别名1...(别名２)(别名１，别名２)
    from 表１　别名１
    inner | left|right join 表２　别名２
    on 连接条件
    where 筛选条件
    ```

    **注：要删除那个表中对应的记录，取决与delete后面的别名是那个表**

- 方法２：truncate

  - 语法：

    ```sql
    #整个表清空，不能加条件
    truncate table 表名;
    ```

- 方法１vs方法２

  1. delete 可以加where条件，truncate不能加条件;
  2. truncate删除，效率较高
  3. 假如要剔除的表中有自增长列，如果使用delete剔除后，再插入数据，自增长列的值从断点开始，而truncate剔除后，再插入数据．自增长列的值从１开始
  4. truncate删除没有返回值，delete删除有返回值．
  5. truncate删除不能回滚，delete删除可以回滚

## DDL语言

创建：create  修改：alter　删除：drop

### 库的管理

- 创建

  ```sql
  create datebase 库名
  
  #但是如果该库已存在则会出现错误
  create database 库名　if not exists 库名;
  ```

  

- 修改

  ```sql
  #一般不修改库，不安全
  #更改库的字符集
  alter datebase 库名　character set gbk;
  ```

  

- 删除

  ```sql
  drop database 库名 if exists 库名;
  ```

  

### 表的管理

- 创建

  ```sql
  create table 表名(
  	列名　列的类型 [[长度],[约束]],
  	列名　列的类型 [[长度],[约束]],
  	...
  )
  ```

  

- 修改

  ```Sql
  #修改列名
  alter table 表名　change column 列名　新列名　类型;
  #修改列的类型
  alter  table 表明 modify column 列名　新类型;
  #添加新列
  alter table 表名　add column 新列名　新类型;
  #删除列
  alter table 表名　drop column 列名;
  #修改表名
  alter table 表明　rename to 新表名;
  ```

  

- 删除

  ```sql
  drop table if exists 表名;
  show tables;　#显示库中所有表
  ```

- 复制

  ```sql
  #仅仅复制表的结构
  create table 表名 like 参考表名;
  
  #复制表的结构+数据
  create table 表名 select * from author;
  
  #仅仅复制某些结构字段，不要数据(筛选条件不满足即可)
  create table 表名 select 某些字段 from 参考表名　where 0;
  
  ```

  注：跨库查询 from 后面使用　库名.表名 即可．

## 基本数据类型

- 数值型：

  - 整数：Tinyint(8 B) , Smallint(16), Mediumint(24), Int(32), BIgInt(64)

    ```sql
    #整数默认有符号
    #设置无符号
    create table 表名(
    	列名 int unsigned；
    )
    #如果超出表示范围出错　
    #对于整数后面的长度，只表示显示的长度，不表示实际的大小,并且使用zerofill默认无符号
    create table 表名(
    	列名　int(7) zerofill unsigned;
    )
    ```

    

  - 小数：**Ｍ和Ｄ，Ｄ是小数点后保留Ｄ位，整数位为M-D 位，如果超出范围，则插入临界值9999填补**

    - 浮点型：float(M,D), double(M,D)，根据插入数值决定精度
    - 定点型：dec(M,D), decimal(M,D)，默认M=10，D=0

- 字符型：**Ｍ表示最多的字符数，不是最多的字节数**

  - 较短文本：char \ varchar，char表示固定长度的字符，varchar可变

  但char的效率高一点，varchar虽然节省空间，但效率低一些

  - 较长文本：text  \ blob（较长的二进制数据）
  - 其他：binary,varbinary,enum,set,

- 日期型：

  - data(4,日期), datetime(8,日期+时间), timestamp(4，自1970年的秒数), time(3), year(1)

  - date范围(1000 - 9999)，不受时区影响

    timestamp(1970 - 2038)，受时区影响

    ```sql
    #显示时区
    show variables like 'time_zone';
    #修改时区
    set time_zone = '+9:00';
    ```


## 约束

含义：一种限制，用于限制表中的数据，为了保证表中的数据的准确和可靠性，**有列级约束(六大约束都能添加，但外建约束没有效果)和表级约束(写在最后，除了非空，默认，其他都支持)**

```sql
create table 表名(
	字段名　字段类型　列级约束,
	字段名　字段类型,
	表级约束
)
```



1. not null
2. default：默认，用于保证该字段有默认值
3. primary key：主键，保证该字段值唯一且不能为空
4. unique：保证该字段值唯一，但可以为空
5. check：检查约束（mysql不支持，限制字段的取值）
6. foreign key：外键，用于限制两个表的关系，在从表中添加外建约束，用于引用主表中某列的值．保证从表的该字段的值必须来源于主表中存在的g

```sql
create table stuinfo(
	id int primary key,							#主键
	stuname varchar(20) not null,				#非空
	gender char(1) check(gender in ('男','女')), #检查约束
	seat int unique,							#唯一
	age int default 18,							#默认
	majorId int foreign key references major(id)#外键约束
);
```

- **主键vs唯一**：主键不为空，唯一可为空(且null也是唯一)；

  一个表只能有一个主键，唯一可多个；

  主键支持多个字段值组合，唯一也可以支持多字段组合

- **外键**：要求在从表中设置外键关系；

  从表的外键列的类型和主表关联列的类型要求一致或兼容，名称无要求；

  主表的关联列必须是一个key（一般是主键或唯一）;

  插入数据时，先插入主表，再插从表；删除数据，先删从表，再删主表

  
  
  

## 标识列

可以不用手动插入值，由系统默认提供.

```sql
show variables like 'auto_increament' #可显示表示列的属性信息
#结果出现
#auto_increment_increment　自增长的步长
#auto_increment_offset		自增长的起始

#修改步长
set auto_increment_increment = 3; 
```

- 创建表时设置标识列

  ```sql
  create table 表名(
  	id int primary key auto_increment,
  	name varchar(20)
  );
  insert into 表名 values(null, 'john');
  ```

- 修改表时设置标识列

  ```sql
  alter table 表名 modify column 列名　int auto_increment;
  ```

- 修改表时删除标识列

  ```sql
  alter table 表名　modify column 列名 int;
  ```



- 特点：

  - 标识符**不一定和primary key搭配**，是键(唯一，外键)都行
  - 一个表只能有１个标识列
  - 标识列的类型只能是**数值型**
  - 可以通过set设置步长，也可手动插入值设置起始

  

## 事务

Transaction Control Language 事务控制语言

一个或一组sql语句组成一个执行单元，这个执行单元**要么全部执行，要么全部不执行．**执行失败，整个事务回滚，回到初状态

```show engines```可以显示mysql支持的存储引擎，用的最多的有：innodb, myisam, memory等，其中*innodb* 支持事务，而 *myisam*,*memory* 不支持事务．



### 事务的ACID属性

1. 原子性（Atomicity）:事务是一个不可分割的工作单位，要么发生要么不发生．
2. 一致性（Consistency）：事务必须使数据库从一个一致性状态变换为另一个一致性状态使用
3. 隔离性（Isolation）：一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰（**很多时候需要隔离级别实现**）
4. 持久性（Durability）：一个事务一旦提交，对数据库的改变就是永久性的，接下来的其他操作或数据库故障不应对其有影响．

### 事务的创建

- 隐式事物：事务没有明显的开始和结束的标记，比如insert,update,delete

  ```sql 
  show variables like 'autocommit'; #自动提交　on 开启
  ```

- 显式事务：**必须先设置自动提交功能为禁用**

  ```sql
  set autocommit = 0;	#只针对当前会话有效
  ```

  - 步骤１：开启事务
  - 步骤２：编写事务中的sql语句(select, insert, update, delete)
  - 步骤３：结束事务（commit;提交事物，rollback;回滚）

  ```sql
  # 1
  set autocommit = 0;
  start transaction;#这句也可不加
  # 2
  update account set balance 
  # 3
  [rollback] [commit];
  
  ```

  ### 事务的并发问题

  **如果同时运行的多个事务，当这些事务访问数据库中相同的数据时，没有采取隔离机制，就会导致各种并发问题．**

- **脏读**：一个事务Ａ修改数据，但还没有提交，另外一个事务Ｂ读取了修改后的值，若Ａ将事务回滚，则Ｂ出现脏读．
- **不可重复读**：事务Ａ读取了一个字段，之后事务Ｂ对其进行更新并提交，事务Ａ还未提交，此时再读一次结果又不同了．
- **幻读**：一个事务Ａ读取了一个字段，另外一个事务Ｂ插入一些新的行并提交，之后Ａ在事务结束之前又读取了同一个表，此时多出了几行

这些错误，是在事务执行过程中发生的．

### 事务的隔离级别

四种隔离级别

- Read uncommited(读未提交数据)

  允许事务读取未被其他事务提交的更新，会出现脏读，不可重复读，幻读

- Read commited(读已提交数据)

  只允许事务读取已经被其他事务提交的变更，可以避免脏读，其他仍会出现

- Repeatable read(可重复读)

  确保事务可以**多次**从一个字段中读取相同的值，但这个事务执行过程中禁止其他事务对这个字段进行更新，**可以避免脏读不可重复读**，但仍会出现幻读

- Serializable(串行化)

  可以从一个表中读取相同的行，在整个事务持续期间，禁止其他事务对该表执行插入，更新和删除操作．能避免并发问题，但性能很低，阻塞

```sql
#查看默认隔离级别
select @@tx_isolation;
#设置隔离级别(mysql默认repeatable read,oracle 默认read commited)
set session transaction isolation level read uncommitted;
set session transaction isolation level read committed;
set session transaction isolation level repeatable read;
set [session|global] transaction isolation level serializable;


```

**设置保存点**

```sql
set autocommit = 0;
start transaction;
delete from account where id = 25;
savepoint a; #搭配rollback使用,回滚到保存点
delete from account where id = 28;
rollback;
```

## 存储过程

- 含义：一组预先编译好的SQL语句集合，理解成批处理语句

  1. 提高代码重用性
  2. 简化操作
  3. 减少了编译次数并且减少了和数据库的连接次数，提高了效率

- 创建语法

  ```sql
  #需要先设置结束符，因为若以;作为存储过程的结束符，而存储过程内的语句也以；分隔，则产生歧义  
  #使用$作为结束符，这一句不能以；结束，否则是以　$; 作为结束符
  delimiter $
  create procedure 过程名 (参数列表)
  begin
  	#一组sql操作;
  end$
  
  
  ```

  其中对于参数列表，与函数不同，返回值也是在参数列表中声明，使用参数模式，因此参数列表中每一项由参数模式，参数名和参数类型组成．

  - 参数模式：　in , out , inout

  ```sql
  #举例
  in stuname varchar(20)
  ```

  如果存储过程体仅仅有一句话，*begin* 和 *end* 可以省略，**存储过程体中的每条sql语句**的结尾必须加分号，**存储过程的结尾可以使用*delimiter* 重新设置．** 并且由于设置了delimiter，除非重新设为分号，否则后面的sql语句都需要用$

- 调用语法

  ```sql
  call 存储过程名(实参列表);
  ```

- 删除语法

  ```sql
  drop procedure 存储过程名;#只能删除一个
  ```

- 查看语法

  ```sql
  #不能使用desc
  show create procedure 存储过程名;
  ```

  

- 案例

  - 空参列表

    ```sql
    #插入到admin表中五条记录
    delimiter $
    create procedure myp1()
    begin
    	insert into admin (usrname, password) values
    	('john1','0000'),('lily','1111'),('Tom','2222'),('Toby','4444'),('Tina','5555');
    end $
    call myp1()$
    ```

  - 带in参数模式的列表

    ```sql
    #创建存储过程实现，用户是否登录成功
    create procedure myp2(in username varchar(20), in password varchar(20))
    begin
    	declare result int default 0;	#声明变量
    	select count(*) into result		#判断是否有该用户名和密码对应的条目，若为０则失败
    	from admin
    	where admin.username = username
    	and admin.password = password;
    	select if(result >0 ,'成功','失败');
    end $
    ```

  - 带out参数模式的列表

    ```sql
    #根据女神名，输出她的男朋友及魅力值
    create procedure myp3(in beautyName varchar(20),out boyName varchar(20),out userCP int)
    begin 
    	select bo.boyName, bo.userCP into boyName,userCP	#将数据传入变量！
    	from boys bo
    	inner join beauty b on bo.id = b.boyfriend_id
    	where b.name = beautyName;
    end$
    ```

  - 带inout参数模式的列表

    ```sql
    #传入a,b两个值，最终a和b都翻倍并返回
    create procedure myp8(inout a int, inout b int)
    begin 
    	set a = a*2;
    	set b = b*2;
    end$
    
    #调用
    set @m = 10$
    set @b = 20$
    call myp8(@m,@n)$
    select @m,@n $
    ```

  - ```sql
    create procedure cmpdate (in birth1 datetime, in birth2 datetime, out result int)
    begin
    	select datediff(birth1,birth2) into result;
    end$
    ```

  - ```sql
    #创建一个存储过程，实现传入一个日期，格式化为xx年yy月zz日
    create procedure date_format(in mydate datetime , out str varchar(50))
    begin 
    	select date_format(mydate,'%y年%m月%d日') into str;
    end$
    ```

    **字符转日期　str_to_date    ,   日期转字符　date_format**

  - ```sql
    #传入女神名，返回：'女神　and 男神' 格式的字符串
    create procedure test_pro5(in beautyName varchar(20), out str varchar(50))
    begin
    	select concat(beautyName,'and',ifnul(boyName,'null')) into str
    	from boys bo
    	right join beauty b 
    	on b.boyfriend_id = bo.id
    	where b.name = beautyName
    end$
    ```

## 函数

- 创建语法

  ```sql
  create function 函数名(参数列表) returns 返回类型
  begin
  	函数体
  end
  ```

  注意：参数列表包含两个部分：参数名　参数类型（不再有参数模式）

  ​			函数体中必有return语句，如果没有则会报错

  ​			若函数体中只有一句话则可以省略return

  ​			同样使用 *delimiter* 设置结束标记

- 调用语法

  ```sql
  #不是使用call !!! 使用select
  select 函数名(参数列表)
  ```

- 查看函数

  ```sql
  show create function 函数名;
  ```

- 删除语法

  ```sql
  drop function 函数名;
  ```

- 案例

  - 无参有返回

    ```sql
    ＃返回公司的员工人数
    create function myf1() return int
    begin
    	declare c int default 0;
    	select count(*) into c
    	from employees;
    	return c;
    end $
    ```

  - 有参有返回

    ```sql
    #根据员工名，返回它的工资
    create function myf2(empName varchar(20)) returns double
    begin
    	set @sal = 0;
    	select salary into @sal
    	from employees
    	where last_name = empName;
    	return @sal;
    end$
    ```

## 流程控制结构

1. 顺序结构：程序从上到下依次执行
2. 分支结构：程序从两条或多条路径中选择一条去执行
3. 循环结构：程序在满足一定条件的基础上，重复执行的一段代码

### 分支结构

- if函数

  - 功能：实现简单的双分支

  - 语法：

    ```sql
    if(表达式１,表达式２,表达式３)
    #如果表达式１成立，则返回表达式２的值，否则返回表达式３的值
    ```

- case结构

  - 情况１：类型swtich语句，一般用于实现等值判断

    - 语法

      ```sql
      case 变量｜表达式｜字段
      when 要判断的值 then 返回的值１或语句１;
      when 要判断的值 then 返回的值２或语句２;
      ...
      else 要返回的值n或语句n;
      end case;
      ```

      

  - 情况２：类似多重if语句，一般用于实现区间判断

    - 语法

      ```sql
      case 
      when 要判断的条件１ then 返回的值１或语句1;
      when 要判断的条件２ then 返回的值２或语句2;
      ...
      else 要返回的值n或语句n;
      end case;
      ```

  - 特点：

    1. 可以作为表达式，嵌套在其他语句中在使用，可以放在任何地方，begin　end中或外

       可以作为独立的语句去使用，此时只能放在begin end中

    2. 如果when中的值或者条件成立，则执行对应then后面的语句，并且结束case

       如果都不满足则执行else中的语句或值

    3. else可以省略，如果else省略了，并且所有when条件都不满足，则返回null

    

##  理论

